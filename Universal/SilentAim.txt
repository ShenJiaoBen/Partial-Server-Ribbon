return function(Library, Options, Toggles)
    local SilentAimSettings = getgenv().SilentAimSettings
    local BulletTracerSettings = getgenv().BulletTracerSettings

    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local Workspace = game:GetService("Workspace")
    local CoreGui = game:GetService("CoreGui")
    local Debris = game:GetService("Debris")
    local VirtualInputManager = game:GetService("VirtualInputManager")
    
    local LocalPlayer = Players.LocalPlayer
    local Mouse = LocalPlayer:GetMouse()
    local camera = Workspace.CurrentCamera
    local Cam = camera
    local WorldToViewportPoint = camera.WorldToViewportPoint
    local GetPlayers = Players.GetPlayers
    local FindFirstChild = game.FindFirstChild
    local RenderStepped = RunService.RenderStepped
    local GetMouseLocation = UserInputService.GetMouseLocation
    local resume = coroutine.resume
    local create = coroutine.create

    local ValidTargetParts = {"Head", "HumanoidRootPart"}
    local PredictionAmount = 0.165

    local currentTargetPart = nil
    local currentRotationAngle = 0
    local currentIndicatorHue = 0
    local npcList = {}
    local targetMap = {}
    local recentShots = {}
    local pendingDamage = {}

    local lockedTargetObject = nil

    local target_indicator_circle = Drawing.new("Circle")
    target_indicator_circle.Visible = false; target_indicator_circle.ZIndex = 1000; target_indicator_circle.Thickness = 2; target_indicator_circle.Filled = false
    
    local target_indicator_lines = {}
    for i = 1, 5 do local line = Drawing.new("Line"); line.Visible = false; line.ZIndex = 1000; line.Thickness = 2; table.insert(target_indicator_lines, line) end
    
    local tracer_line = Drawing.new("Line")
    tracer_line.Visible = false; tracer_line.ZIndex = 998; tracer_line.Color = Color3.fromRGB(255, 255, 0); tracer_line.Thickness = 1; tracer_line.Transparency = 1

    local overhead_info_texts = {
        Name = Drawing.new("Text"), Health = Drawing.new("Text"), Distance = Drawing.new("Text"), Category = Drawing.new("Text")
    }
    for _, text in pairs(overhead_info_texts) do
        text.Visible = false; text.ZIndex = 1001; text.Font = Drawing.Fonts.Plex; text.Size = 14; text.Color = Color3.fromRGB(255, 255, 255); text.Center = true; text.Outline = true
    end

    local panel_info_bg = Drawing.new("Square")
    panel_info_bg.Visible = false; panel_info_bg.ZIndex = 1002; panel_info_bg.Color = Color3.fromRGB(0, 0, 0); panel_info_bg.Thickness = 0; panel_info_bg.Filled = true; panel_info_bg.Transparency = 0.5
    
    local panel_info_texts = {
        Name = Drawing.new("Text"), Health = Drawing.new("Text"), Distance = Drawing.new("Text"), Category = Drawing.new("Text")
    }
    for _, text in pairs(panel_info_texts) do
        text.Visible = false; text.ZIndex = 1003; text.Font = Drawing.Fonts.Plex; text.Size = 14; text.Color = Color3.fromRGB(255, 255, 255); text.Center = false; text.Outline = true
    end

    local FOVCircleGui = Instance.new("ScreenGui")
    if game:GetService("CoreGui") then
        pcall(function() FOVCircleGui.Parent = game:GetService("CoreGui") end)
    else
        FOVCircleGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    end
    FOVCircleGui.Name = "FOVCircleGui"; FOVCircleGui.ResetOnSpawn = false; FOVCircleGui.IgnoreGuiInset = true; FOVCircleGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    local FOVCircleFrame = Instance.new("Frame", FOVCircleGui)
    FOVCircleFrame.Name = "FOVCircleFrame"; FOVCircleFrame.AnchorPoint = Vector2.new(0.5, 0.5); FOVCircleFrame.Position = UDim2.fromScale(0.5, 0.5); FOVCircleFrame.BackgroundTransparency = 1
    local FOVStroke = Instance.new("UIStroke", FOVCircleFrame)
    FOVStroke.Name = "FOVStroke"; FOVStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border; FOVStroke.Thickness = 1; FOVStroke.Transparency = 0.5
    local FOVCorner = Instance.new("UICorner", FOVCircleFrame)
    FOVCorner.Name = "FOVCorner"; FOVCorner.CornerRadius = UDim.new(1, 0)

    local IndependentPanelGui = Instance.new("ScreenGui")
    if game:GetService("CoreGui") then
        pcall(function() IndependentPanelGui.Parent = game:GetService("CoreGui") end)
    else
        IndependentPanelGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    end
    IndependentPanelGui.Name = "IndependentPanelGui"; IndependentPanelGui.ResetOnSpawn = false; IndependentPanelGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    local IndependentPanelFrame = Instance.new("Frame", IndependentPanelGui)
    IndependentPanelFrame.Name = "PanelFrame"; IndependentPanelFrame.Size = UDim2.fromOffset(160, 100);
    IndependentPanelFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30); IndependentPanelFrame.BackgroundTransparency = 0.3; IndependentPanelFrame.BorderSizePixel = 1; IndependentPanelFrame.BorderColor3 = Color3.new(1,1,1)
    IndependentPanelFrame.Visible = false; IndependentPanelFrame.Active = true
    local IPCorner = Instance.new("UICorner", IndependentPanelFrame); IPCorner.CornerRadius = UDim.new(0, 4)
    local IPListLayout = Instance.new("UIListLayout", IndependentPanelFrame)
    IPListLayout.Padding = UDim.new(0, 5); IPListLayout.SortOrder = Enum.SortOrder.LayoutOrder; IPListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center; IPListLayout.VerticalAlignment = Enum.VerticalAlignment.Center

    local independent_panel_texts = {}
    for i, name in ipairs({"Name", "Health", "Distance", "Category"}) do
        local label = Instance.new("TextLabel", IndependentPanelFrame)
        label.Name = name; label.Size = UDim2.new(1, -10, 0, 15); label.BackgroundTransparency = 1
        label.Font = Enum.Font.SourceSans; label.TextSize = 14; label.TextColor3 = Color3.new(1,1,1); label.TextXAlignment = Enum.TextXAlignment.Left; label.LayoutOrder = i
        independent_panel_texts[name] = label
    end

    IndependentPanelFrame.InputBegan:Connect(function(input) 
        if input.UserInputType == Enum.UserInputType.MouseButton1 and IndependentPanelFrame.Draggable then 
            IndependentPanelFrame.Position = UDim2.fromOffset(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) 
        end 
    end)
    IndependentPanelFrame.InputEnded:Connect(function(input) 
        if input.UserInputType == Enum.UserInputType.MouseButton1 and IndependentPanelFrame.Draggable then 
            SilentAimSettings.IndependentPanelPosition = IndependentPanelFrame.Position.X.Offset .. "," .. IndependentPanelFrame.Position.Y.Offset 
        end 
    end)

    local ExpectedArguments = {
        FindPartOnRayWithIgnoreList = { ArgCountRequired = 3, Args = {"Instance", "Ray", "table", "boolean", "boolean"} },
        FindPartOnRayWithWhitelist = { ArgCountRequired = 3, Args = {"Instance", "Ray", "table", "boolean"} },
        FindPartOnRay = { ArgCountRequired = 2, Args = {"Instance", "Ray", "Instance", "boolean", "boolean"} },
        Raycast = { ArgCountRequired = 3, Args = {"Instance", "Vector3", "Vector3", "RaycastParams"} }
    }

    local HitSounds = {
        ["bell"] = "rbxassetid://6534948092",
        ["metal"] = "rbxassetid://3125624765",
        ["click"] = "rbxassetid://17755696142",
        ["exp"] = "rbxassetid://10070796384"
    }

    local function playHitSound(soundId)
        local sound = Instance.new("Sound")
        sound.Parent = CoreGui
        sound.SoundId = soundId
        sound.Volume = 0.6
        sound:Play()
        Debris:AddItem(sound, sound.TimeLength + 0.2)
    end

    function CalculateChance(Percentage)
        Percentage = math.floor(Percentage)
        return math.random() <= Percentage / 100
    end

    local function getPositionOnScreen(Vector)
        local Vec3, OnScreen = WorldToViewportPoint(camera, Vector)
        return Vector2.new(Vec3.X, Vec3.Y), OnScreen
    end

    local function ValidateArguments(Args, RayMethod)
        local Matches = 0
        if #Args < RayMethod.ArgCountRequired then return false end
        for Pos, Argument in next, Args do if typeof(Argument) == RayMethod.Args[Pos] then Matches = Matches + 1 end end
        return Matches >= RayMethod.ArgCountRequired
    end

    local function getDirection(Origin, Position)
        return (Position - Origin).Unit * 1000
    end

    local function isNPC(obj)
        return obj:IsA("Model") and obj:FindFirstChild("Humanoid") and obj.Humanoid.Health > 0 and obj:FindFirstChild("HumanoidRootPart") and not Players:GetPlayerFromCharacter(obj)
    end

    function getTargetCategory(character)
        if not character then return "无" end
        if Players:GetPlayerFromCharacter(character) then return "玩家" end
        if SilentAimSettings.EnableNameTargeting then
            local name = character.Name:lower()
            for _, whitelistedName in ipairs(SilentAimSettings.WhitelistedNames) do
                if whitelistedName and whitelistedName ~= "" and string.find(name, whitelistedName:lower(), 1, true) then return "添加的" end
            end
        end
        for _, path in ipairs(SilentAimSettings.WhitelistPath) do
            local obj = Workspace:FindFirstChild(path)
            if obj and obj == character then return "路径白名单" end
        end
        if character:FindFirstChild("Humanoid") then return "NPC" end
        return "未知"
    end

    local function updateNPCs()
        local newNpcList = {}
        local addedNpcs = {}
        if SilentAimSettings.EnableNameTargeting and #SilentAimSettings.WhitelistedNames > 0 then
            for _, model in ipairs(Workspace:GetDescendants()) do
                if isNPC(model) then
                    for _, substring in ipairs(SilentAimSettings.WhitelistedNames) do
                        if substring and substring ~= "" and string.find(model.Name:lower(), substring:lower(), 1, true) then
                            if not addedNpcs[model] then table.insert(newNpcList, model); addedNpcs[model] = true; break end
                        end
                    end
                end
            end
        end
        for _, path in ipairs(SilentAimSettings.WhitelistPath) do
            local obj = Workspace:FindFirstChild(path)
            if obj and isNPC(obj) and not addedNpcs[obj] then table.insert(newNpcList, obj); addedNpcs[obj] = true end
        end
        for _, v in ipairs(Workspace:GetChildren()) do
            if isNPC(v) then if not addedNpcs[v] then table.insert(newNpcList, v); addedNpcs[v] = true end end
        end
        npcList = newNpcList
    end

    local function isBlacklisted(name)
        local lowerName = name:lower()
        for _, blacklistedName in ipairs(SilentAimSettings.BlacklistedNames) do
            if blacklistedName:lower() == lowerName then return true end
        end
        return false
    end

    local function isPartVisible(part, customOrigin)
        if not part then return false end
        local localCharacter = LocalPlayer.Character
        if not localCharacter then return false end
        local origin = customOrigin or camera.CFrame.Position
        local direction = part.Position - origin
        local raycastParams = RaycastParams.new()
        raycastParams.FilterType = Enum.RaycastFilterType.Exclude
        raycastParams.FilterDescendantsInstances = {localCharacter, part.Parent}
        local raycastResult = Workspace:Raycast(origin, direction.Unit * direction.Magnitude, raycastParams)
        return not raycastResult
    end

    local function getClosestPlayer_SA()
        local LocalPlayerCharacter = LocalPlayer.Character
        if not LocalPlayerCharacter or not LocalPlayerCharacter:FindFirstChild("HumanoidRootPart") then return nil end
        local localRoot = LocalPlayerCharacter.HumanoidRootPart
        local AimPoint = SilentAimSettings.FixedFOV and (camera.ViewportSize / 2) or GetMouseLocation(UserInputService)
        local candidates = {}
        for _, Player in ipairs(GetPlayers(Players)) do
            if Player ~= LocalPlayer and not (SilentAimSettings.TeamCheck and Player.Team == LocalPlayer.Team) and not isBlacklisted(Player.Name) then
                local Character = Player.Character
                local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
                if Character and Humanoid and Humanoid.Health > 0 then
                    local partForChecks = Character:FindFirstChild(SilentAimSettings.TargetPart) or Character:FindFirstChild("HumanoidRootPart")
                    if not partForChecks then continue end
                    if not (SilentAimSettings.VisibleCheck and not isPartVisible(partForChecks, LocalPlayerCharacter.Head.Position)) then
                        local physicalDist = (localRoot.Position - partForChecks.Position).Magnitude
                        if SilentAimSettings.AllDirectionAim then
                            if physicalDist <= SilentAimSettings.MaxDistance then table.insert(candidates, {character = Character, fov = 0, dist = physicalDist, health = Humanoid.Health}) end
                        else
                            if physicalDist <= SilentAimSettings.MaxDistance then
                                if SilentAimSettings.PriorityMode == "最近的人(无FOV)" then
                                    table.insert(candidates, {character = Character, fov = math.huge, dist = physicalDist, health = Humanoid.Health})
                                else
                                    local ScreenPosition, OnScreen = getPositionOnScreen(partForChecks.Position)
                                    if OnScreen then
                                        local fovDist = (AimPoint - ScreenPosition).Magnitude
                                        if fovDist <= SilentAimSettings.FOVRadius then table.insert(candidates, {character = Character, fov = fovDist, dist = physicalDist, health = Humanoid.Health}) end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        if #candidates == 0 then return nil end
        table.sort(candidates, function(a, b)
            if SilentAimSettings.PriorityMode == "最低血量" then return a.health < b.health
            elseif SilentAimSettings.PriorityMode == "距离最近" or SilentAimSettings.PriorityMode == "最近的人(无FOV)" or SilentAimSettings.AllDirectionAim then return a.dist < b.dist
            else return a.fov < b.fov end
        end)
        return candidates[1].character
    end

    local function getNPCTarget()
        local LocalPlayerCharacter = LocalPlayer.Character
        if not LocalPlayerCharacter or not LocalPlayerCharacter:FindFirstChild("HumanoidRootPart") then return nil end
        local localRoot = LocalPlayerCharacter.HumanoidRootPart
        local AimPoint = SilentAimSettings.FixedFOV and (camera.ViewportSize / 2) or GetMouseLocation(UserInputService)
        local candidates = {}
        for _, NPCModel in ipairs(npcList) do
            if not (SilentAimSettings.TeamCheck and NPCModel.Team and NPCModel.Team == LocalPlayer.Team) and not isBlacklisted(NPCModel.Name) then
                local Humanoid = NPCModel and NPCModel:FindFirstChildOfClass("Humanoid")
                if NPCModel and Humanoid and Humanoid.Health > 0 then
                    local partForChecks = NPCModel:FindFirstChild(SilentAimSettings.TargetPart) or NPCModel.PrimaryPart or NPCModel:FindFirstChild("HumanoidRootPart")
                    if not partForChecks then continue end
                    if not (SilentAimSettings.VisibleCheck and not isPartVisible(partForChecks, LocalPlayerCharacter.Head.Position)) then
                        local physicalDist = (localRoot.Position - partForChecks.Position).Magnitude
                         if SilentAimSettings.AllDirectionAim then
                            if physicalDist <= SilentAimSettings.MaxDistance then table.insert(candidates, {character = NPCModel, fov = 0, dist = physicalDist, health = Humanoid.Health}) end
                         else
                            if physicalDist <= SilentAimSettings.MaxDistance then
                                 if SilentAimSettings.PriorityMode == "最近的人(无FOV)" then table.insert(candidates, {character = NPCModel, fov = math.huge, dist = physicalDist, health = Humanoid.Health})
                                else
                                    local ScreenPosition, OnScreen = getPositionOnScreen(partForChecks.Position)
                                    if OnScreen then
                                        local fovDist = (AimPoint - ScreenPosition).Magnitude
                                        if fovDist <= SilentAimSettings.FOVRadius then table.insert(candidates, {character = NPCModel, fov = fovDist, dist = physicalDist, health = Humanoid.Health}) end
                                    end
                                end
                            end
                         end
                    end
                end
            end
        end
        if #candidates == 0 then return nil end
        table.sort(candidates, function(a, b)
            if SilentAimSettings.PriorityMode == "最低血量" then return a.health < b.health
            elseif SilentAimSettings.PriorityMode == "距离最近" or SilentAimSettings.PriorityMode == "最近的人(无FOV)" or SilentAimSettings.AllDirectionAim then return a.dist < b.dist
            else return a.fov < b.fov end
        end)
        return candidates[1].character
    end

    function getPolygonPoints(center, radius, sides)
        local points = {}
        local rotationOffset = SilentAimSettings.IndicatorRotationEnabled and currentRotationAngle or 0
        for i = 1, sides do
            local angle = (i - 1) * (2 * math.pi / sides) - (math.pi / 2) + rotationOffset
            table.insert(points, Vector2.new(center.X + radius * math.cos(angle), center.Y + radius * math.sin(angle)))
        end
        return points
    end

    function hideAllVisuals()
        target_indicator_circle.Visible = false
        for _, line in ipairs(target_indicator_lines) do line.Visible = false end
        for _, text in pairs(overhead_info_texts) do text.Visible = false end
        panel_info_bg.Visible = false
        for _, text in pairs(panel_info_texts) do text.Visible = false end
        if IndependentPanelFrame then IndependentPanelFrame.Visible = false end
    end

    if Toggles.FOVVisibleToggle then FOVCircleGui.Enabled = Toggles.FOVVisibleToggle.Value end
    if Options.FOVColorPicker then FOVStroke.Color = Options.FOVColorPicker.Value end
    if Options.FOVRadiusSlider then FOVCircleFrame.Size = UDim2.fromOffset(Options.FOVRadiusSlider.Value * 2, Options.FOVRadiusSlider.Value * 2) end
    if Options.TargetIndicatorColorPicker then 
        target_indicator_circle.Color = Options.TargetIndicatorColorPicker.Value 
        for _, line in ipairs(target_indicator_lines) do line.Color = Options.TargetIndicatorColorPicker.Value end
    end
    IndependentPanelFrame.Draggable = not SilentAimSettings.IndependentPanelPinned

    local pos = SilentAimSettings.IndependentPanelPosition:split(",")
    if pos[1] and pos[2] then IndependentPanelFrame.Position = UDim2.fromOffset(tonumber(pos[1]), tonumber(pos[2])) end

    task.spawn(function()
        while task.wait(2) do
            if SilentAimSettings.TargetMode == "NPC" or SilentAimSettings.TargetMode == "所有" then updateNPCs() end
        end
    end)

    local lastHealthValues = {}
    local damageIndicators = {}
    local DAMAGE_INDICATOR_FADE_TIME = 1
    local lastTargetCharacter = nil
    local lockedRandomPart = nil
    local lastAutoFireTime = 0

    resume(create(function()
        RenderStepped:Connect(function()
            if Options.FOVColorPicker then FOVStroke.Color = Options.FOVColorPicker.Value end
            if Options.TracerColorPicker and tracer_line.Visible then tracer_line.Color = Options.TracerColorPicker.Value end
            
            if SilentAimSettings.IndicatorRotationEnabled then currentRotationAngle = (currentRotationAngle + (SilentAimSettings.IndicatorRotationSpeed / 50)) % (math.pi * 2) end
            if SilentAimSettings.IndicatorRainbowEnabled then currentIndicatorHue = (currentIndicatorHue + (SilentAimSettings.IndicatorRainbowSpeed / 200)) % 1 end
            
            local currentTime = tick()
            for i = #recentShots, 1, -1 do
                if currentTime - recentShots[i].time > 1 then table.remove(recentShots, i) end
            end

            local isEnabled = Toggles.EnabledToggle and Toggles.EnabledToggle.Value
            currentTargetPart = nil
            local currentTargetCharacter = nil

            if isEnabled then
                if lockedTargetObject then
                     if lockedTargetObject.Parent and not isBlacklisted(lockedTargetObject.Name) then
                        if lockedTargetObject:IsA("Player") then currentTargetCharacter = lockedTargetObject.Character
                        elseif lockedTargetObject:IsA("Model") then currentTargetCharacter = lockedTargetObject end
                    else
                        lockedTargetObject = nil
                        if Options.TargetSelectorDropdown then Options.TargetSelectorDropdown:SetValue("无") end
                    end
                else
                    local targetMode = SilentAimSettings.TargetMode
                    local playerTarget, npcTarget
                    if targetMode == "玩家" or targetMode == "所有" then playerTarget = getClosestPlayer_SA() end
                    if targetMode == "NPC" or targetMode == "所有" then npcTarget = getNPCTarget() end

                    if playerTarget and npcTarget then
                        local priority = SilentAimSettings.PriorityMode
                        if priority == "最低血量" then
                            local pHumanoid = playerTarget:FindFirstChildOfClass("Humanoid"); local nHumanoid = npcTarget:FindFirstChildOfClass("Humanoid")
                            currentTargetCharacter = (pHumanoid and nHumanoid and pHumanoid.Health <= nHumanoid.Health) and playerTarget or npcTarget
                        else
                            local pDist = (LocalPlayer.Character.HumanoidRootPart.Position - playerTarget.HumanoidRootPart.Position).Magnitude
                            local nDist = (LocalPlayer.Character.HumanoidRootPart.Position - npcTarget.HumanoidRootPart.Position).Magnitude
                            currentTargetCharacter = pDist < nDist and playerTarget or npcTarget
                        end
                    else
                        currentTargetCharacter = playerTarget or npcTarget
                    end
                end
            end

            if currentTargetCharacter ~= lastTargetCharacter then lockedRandomPart = nil end
            lastTargetCharacter = currentTargetCharacter

            if currentTargetCharacter then
                local humanoid = currentTargetCharacter:FindFirstChildOfClass("Humanoid")
                if not humanoid or humanoid.Health <= 0 then
                    currentTargetCharacter = nil; currentTargetPart = nil
                else
                    local baseTargetPart = nil
                    if SilentAimSettings.LeakAndHitMode then
                        for _, part in ipairs(currentTargetCharacter:GetDescendants()) do
                            if part:IsA("BasePart") and part.Parent == currentTargetCharacter then
                                if isPartVisible(part) then baseTargetPart = part; break end
                            end
                        end
                    else
                        local targetPartName = SilentAimSettings.TargetPart
                        if targetPartName == "Random" then
                            if not lockedRandomPart or not lockedRandomPart.Parent or lockedRandomPart.Parent ~= currentTargetCharacter then
                                lockedRandomPart = currentTargetCharacter[ValidTargetParts[math.random(1, #ValidTargetParts)]]
                            end
                            baseTargetPart = lockedRandomPart
                        else
                            baseTargetPart = currentTargetCharacter:FindFirstChild(targetPartName) or currentTargetCharacter:FindFirstChild("HumanoidRootPart")
                        end
                    end

                    if baseTargetPart then
                        if SilentAimSettings.HeadshotChanceEnabled and CalculateChance(SilentAimSettings.HeadshotChance) then
                            local headPart = currentTargetCharacter:FindFirstChild("Head")
                            if headPart then currentTargetPart = headPart else currentTargetPart = baseTargetPart end
                        else
                            currentTargetPart = baseTargetPart
                        end
                    else
                        currentTargetPart = nil
                    end
                end
            end

            if isEnabled and currentTargetPart then
                local humanoid = currentTargetPart.Parent:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    if SilentAimSettings.AutoFire then
                        if tick() - lastAutoFireTime >= SilentAimSettings.AutoFireDelay then
                            local _, isOnScreen = getPositionOnScreen(currentTargetPart.Position)
                            if isOnScreen or not SilentAimSettings.VisibleCheck then
                                VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
                                task.delay(0.05, function() VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1) end)
                                lastAutoFireTime = tick()
                            end
                        end
                    end

                    local currentHealth = humanoid.Health
                    local lastHealth = lastHealthValues[humanoid]
                    if lastHealth and currentHealth < lastHealth then
                        local damage = math.floor(lastHealth - currentHealth)
                        if damage > 0 then
                            if not pendingDamage[humanoid] then pendingDamage[humanoid] = { damage = 0, lastUpdate = tick(), position = currentTargetPart.Position } end
                            pendingDamage[humanoid].damage = pendingDamage[humanoid].damage + damage
                            pendingDamage[humanoid].lastUpdate = tick()
                            pendingDamage[humanoid].position = currentTargetPart.Position

                            local selectedSoundName = Options.HitSound.Value
                            if selectedSoundName ~= '关闭' then
                                local soundId = HitSounds[selectedSoundName]
                                if soundId then playHitSound(soundId) end
                            end
                            local dist = 0
                            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then dist = (LocalPlayer.Character.HumanoidRootPart.Position - currentTargetPart.Position).Magnitude end
                            if getgenv().LogHit then getgenv().LogHit(currentTargetCharacter.Name, damage, currentHealth, dist) end
                        end
                    end
                    lastHealthValues[humanoid] = currentHealth
                end
            end
            
            local DAMAGE_ACCUMULATION_WINDOW = 0.01
            for humanoid, data in pairs(pendingDamage) do
                if currentTime - data.lastUpdate > DAMAGE_ACCUMULATION_WINDOW then
                    if SilentAimSettings.ShowDamageNotifier and data.damage > 0 then
                        local screenPos, onScreen = getPositionOnScreen(data.position)
                        if onScreen then
                            local indicator = {}; indicator.Created = tick(); indicator.Position = screenPos;
                            indicator.TextObject = Drawing.new("Text"); indicator.TextObject.Font = Drawing.Fonts.Monospace;
                            indicator.TextObject.Text = string.format("-%d", data.damage); indicator.TextObject.Color = Color3.fromRGB(255, 50, 50);
                            indicator.TextObject.Size = 20; indicator.TextObject.Center = true; indicator.TextObject.Outline = true
                            table.insert(damageIndicators, indicator)
                        end
                    end
                    pendingDamage[humanoid] = nil
                end
            end

            for i = #damageIndicators, 1, -1 do
                local indicator = damageIndicators[i]; local age = tick() - indicator.Created
                if age > DAMAGE_INDICATOR_FADE_TIME then
                    indicator.TextObject:Remove(); table.remove(damageIndicators, i)
                else
                    local progress = age / DAMAGE_INDICATOR_FADE_TIME
                    indicator.TextObject.Position = indicator.Position - Vector2.new(0, progress * 40)
                    indicator.TextObject.Transparency = progress; indicator.TextObject.Visible = true
                end
            end

            hideAllVisuals()

            if isEnabled and currentTargetPart then
                local RootToViewportPoint, IsOnScreen = getPositionOnScreen(currentTargetPart.Position)

                if IsOnScreen and Toggles.ShowTargetToggle and Toggles.ShowTargetToggle.Value then
                    local indicatorRadius = SilentAimSettings.TargetIndicatorRadius
                    local indicatorStyle = Options.IndicatorStyleDropdown.Value
                    local finalIndicatorColor; local isTargetVisible = isPartVisible(currentTargetPart)
                    if isTargetVisible then finalIndicatorColor = Color3.fromRGB(0, 255, 0); indicatorRadius = indicatorRadius * 0.6
                    elseif SilentAimSettings.IndicatorRainbowEnabled then finalIndicatorColor = Color3.fromHSV(currentIndicatorHue, 1, 1)
                    else finalIndicatorColor = Options.TargetIndicatorColorPicker.Value end
                    
                    local breathingScale = 1
                    if SilentAimSettings.IndicatorBreathingEnabled then
                        breathingScale = SilentAimSettings.IndicatorBreathingMin + (SilentAimSettings.IndicatorBreathingMax - SilentAimSettings.IndicatorBreathingMin) * (math.sin(tick() * SilentAimSettings.IndicatorBreathingSpeed * math.pi * 2) * 0.5 + 0.5)
                    end
                    
                    if indicatorStyle == "Circle" then
                        target_indicator_circle.Visible = true; target_indicator_circle.Color = finalIndicatorColor; target_indicator_circle.Radius = indicatorRadius * breathingScale; target_indicator_circle.Position = RootToViewportPoint
                    elseif indicatorStyle == "Triangle" then
                        local points = getPolygonPoints(RootToViewportPoint, indicatorRadius * breathingScale, 3)
                        for i = 1, 3 do local line = target_indicator_lines[i]; line.Visible = true; line.Color = finalIndicatorColor; line.From = points[i]; line.To = points[i % 3 + 1] end
                    elseif indicatorStyle == "Pentagram" then
                        local points = getPolygonPoints(RootToViewportPoint, indicatorRadius * breathingScale, 5)
                        local pentagram_order = {1, 3, 5, 2, 4}
                        for i = 1, 5 do local line = target_indicator_lines[i]; line.Visible = true; line.Color = finalIndicatorColor; line.From = points[pentagram_order[i]]; line.To = points[pentagram_order[i % 5 + 1]] end
                    elseif indicatorStyle == "十字准星" then
                        local length = SilentAimSettings.CrosshairLength * breathingScale
                        local gap = SilentAimSettings.CrosshairGap * breathingScale
                        local center = RootToViewportPoint
                        local rotation = SilentAimSettings.IndicatorRotationEnabled and currentRotationAngle or 0
                        local cos, sin = math.cos(rotation), math.sin(rotation)
                        local function rotate(v) return Vector2.new(v.X * cos - v.Y * sin, v.X * sin + v.Y * cos) end
                        local points = { {From = rotate(Vector2.new(0, -length)) + center, To = rotate(Vector2.new(0, -gap)) + center}, {From = rotate(Vector2.new(0, length)) + center, To = rotate(Vector2.new(0, gap)) + center}, {From = rotate(Vector2.new(-length, 0)) + center, To = rotate(Vector2.new(-gap, 0)) + center}, {From = rotate(Vector2.new(length, 0)) + center, To = rotate(Vector2.new(gap, 0)) + center} }
                        for i = 1, 4 do target_indicator_lines[i].Visible = true; target_indicator_lines[i].Color = finalIndicatorColor; target_indicator_lines[i].From = points[i].From; target_indicator_lines[i].To = points[i].To end
                    elseif indicatorStyle == "三线准星" and SilentAimSettings.ThreeLineCrosshairEnabled then
                        local length = SilentAimSettings.ThreeLineCrosshairLength * breathingScale; local gap = SilentAimSettings.ThreeLineCrosshairGap * breathingScale; local center = RootToViewportPoint; local rotation = SilentAimSettings.IndicatorRotationEnabled and currentRotationAngle or 0
                        for i = 1, 3 do
                            local angle = rotation + (i - 1) * (math.pi * 2 / 3); local dir = Vector2.new(math.cos(angle), math.sin(angle)); local start = center + dir * gap; local endPos = center + dir * length
                            target_indicator_lines[i].Visible = true; target_indicator_lines[i].Color = finalIndicatorColor; target_indicator_lines[i].From = start; target_indicator_lines[i].To = endPos
                        end
                    end
                end

                if SilentAimSettings.ShowInfoPanel then
                    local showAnyInfo = Toggles.ShowTargetNameToggle.Value or false
                    if showAnyInfo then
                        local player = Players:GetPlayerFromCharacter(currentTargetCharacter)
                        local localRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                        local humanoid = currentTargetCharacter:FindFirstChildOfClass("Humanoid")
                        if humanoid and localRoot then
                            local targetName = player and player.DisplayName or currentTargetCharacter.Name
                            local health = math.floor(humanoid.Health)
                            local dist = math.floor((localRoot.Position - currentTargetPart.Position).Magnitude)
                            local infoStyle = SilentAimSettings.TargetInfoStyle
                            
                            if infoStyle == "独立面板" then
                                IndependentPanelFrame.Visible = true
                                independent_panel_texts.Name.Visible = Toggles.ShowTargetNameToggle.Value
                                independent_panel_texts.Health.Visible = true
                                independent_panel_texts.Distance.Visible = true
                                independent_panel_texts.Category.Visible = false
                                if Toggles.ShowTargetNameToggle.Value then independent_panel_texts.Name.Text = "目标: " .. targetName end
                                independent_panel_texts.Health.Text = string.format("血量: %d", health)
                                independent_panel_texts.Distance.Text = string.format("距离: %dm", dist)
                            elseif infoStyle == "面板" and IsOnScreen then
                                local indicatorRadius = SilentAimSettings.TargetIndicatorRadius
                                local linesDrawn = 0; local lineHeight = 15; local infoPos = RootToViewportPoint + Vector2.new(indicatorRadius + 5, -22)
                                if Toggles.ShowTargetNameToggle.Value then local textObj = panel_info_texts.Name; textObj.Text = targetName; textObj.Position = infoPos + Vector2.new(5, 5 + (linesDrawn * lineHeight)); textObj.Visible = true; linesDrawn = linesDrawn + 1 end
                                if linesDrawn > 0 then panel_info_bg.Position = infoPos; panel_info_bg.Size = Vector2.new(120, 10 + (linesDrawn * lineHeight)); panel_info_bg.Visible = true end
                            elseif infoStyle == "头顶" and IsOnScreen then
                                local indicatorRadius = SilentAimSettings.TargetIndicatorRadius
                                local linesDrawn = 0; local lineHeight = 15; local base_y = RootToViewportPoint.Y - indicatorRadius - 10
                                if Toggles.ShowTargetNameToggle.Value then local textObj = overhead_info_texts.Name; textObj.Text = string.format("[%s]", targetName); textObj.Position = Vector2.new(RootToViewportPoint.X, base_y - (linesDrawn * lineHeight)); textObj.Visible = true; linesDrawn = linesDrawn + 1 end
                            end
                        end
                    end
                end
            elseif isEnabled and SilentAimSettings.ShowInfoPanel then
                local infoStyle = SilentAimSettings.TargetInfoStyle
                if infoStyle == "独立面板" then
                    IndependentPanelFrame.Visible = true
                    independent_panel_texts.Name.Visible = true
                    independent_panel_texts.Health.Visible = true
                    independent_panel_texts.Distance.Visible = false
                    independent_panel_texts.Category.Visible = false
                    independent_panel_texts.Name.Text = "状态: 自动索敌中..."
                    independent_panel_texts.Health.Text = "目标: 无"
                end
            end

            if Toggles.ShowTracerToggle and Toggles.ShowTracerToggle.Value and isEnabled and currentTargetPart then
                local targetHead = currentTargetCharacter and currentTargetCharacter:FindFirstChild("Head")
                local tracerTargetPosition = (targetHead and targetHead.Position) or currentTargetPart.Position
                local y_offset = SilentAimSettings.Tracer_Y_Offset
                local finalTracerPosition = tracerTargetPosition - Vector3.new(0, y_offset, 0)
                local targetScreenPos, IsOnScreen = getPositionOnScreen(finalTracerPosition)
                tracer_line.Visible = IsOnScreen
                if IsOnScreen and Options.TracerColorPicker then tracer_line.From = camera.ViewportSize / 2; tracer_line.To = targetScreenPos; tracer_line.Color = Options.TracerColorPicker.Value end
            else
                tracer_line.Visible = false
            end
            
            if Toggles.FOVVisibleToggle and Toggles.FOVVisibleToggle.Value then
                if Toggles.FixedFOVToggle.Value then FOVCircleFrame.Position = UDim2.fromScale(0.5, 0.5) else local mousePos = GetMouseLocation(UserInputService); FOVCircleFrame.Position = UDim2.fromOffset(mousePos.X, mousePos.Y) end
            end
        end)
    end))

    getgenv().InitializeHooks = function()
        if getgenv().HooksInitialized then return end
        getgenv().HooksInitialized = true

        local oldNamecall
        oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(...)
            local Method = getnamecallmethod()
            local Arguments = {...}
            local self = Arguments[1]

            if checkcaller() then return oldNamecall(...) end

            if BulletTracerSettings and BulletTracerSettings.Enabled and (Method == "FireServer" or Method == "InvokeServer") then
                task.spawn(function()
                    pcall(function()
                        for i, v in pairs(Arguments) do
                            local targetPos = nil
                            if typeof(v) == "Vector3" then targetPos = v
                            elseif typeof(v) == "CFrame" then targetPos = v.Position
                            elseif typeof(v) == "table" and v.Position and typeof(v.Position) == "Vector3" then targetPos = v.Position end
                            
                            if targetPos and getgenv().CreateBeamTracer then
                                local dist = (targetPos - camera.CFrame.Position).Magnitude
                                if dist > 5 and dist < 10000 then getgenv().CreateBeamTracer(targetPos) end
                            end
                        end
                    end)
                end)
            end

            if SilentAimSettings.Enabled and CalculateChance(SilentAimSettings.HitChance) and currentTargetPart then
                local currentMethod = SilentAimSettings.SilentAimMethod
                local shotOrigin = nil
                
                if (Method == "FindPartOnRayWithIgnoreList" and currentMethod == Method) or
                (Method == "FindPartOnRayWithWhitelist" and currentMethod == Method) or
                ((Method == "FindPartOnRay" or Method == "findPartOnRay") and currentMethod:lower() == Method:lower()) then
                    
                    if ValidateArguments(Arguments, ExpectedArguments[Method] or ExpectedArguments["FindPartOnRay"]) then
                        shotOrigin = Arguments[2].Origin
                        if SilentAimSettings.BulletTP then shotOrigin = currentTargetPart.Position + (getDirection(Arguments[2].Origin, currentTargetPart.Position).Unit * -2) end
                        table.insert(recentShots, {origin = shotOrigin, time = tick()})
                        
                        if SilentAimSettings.Wallbang then return currentTargetPart, currentTargetPart.Position, currentTargetPart.CFrame.LookVector, currentTargetPart.Material end
                        
                        if SilentAimSettings.BulletTP then Arguments[2] = Ray.new(shotOrigin, (currentTargetPart.Position - shotOrigin).Unit * 100)
                        else Arguments[2] = Ray.new(Arguments[2].Origin, getDirection(Arguments[2].Origin, currentTargetPart.Position)) end
                        local result = oldNamecall(unpack(Arguments))
                        return result
                    end
                elseif Method == "Raycast" and currentMethod == Method then
                    if ValidateArguments(Arguments, ExpectedArguments.Raycast) then
                        shotOrigin = Arguments[2]
                        if SilentAimSettings.BulletTP then shotOrigin = currentTargetPart.Position + (getDirection(Arguments[2], currentTargetPart.Position).Unit * -2); Arguments[2] = shotOrigin end
                        table.insert(recentShots, {origin = shotOrigin, time = tick()})
                        
                        if SilentAimSettings.Wallbang then
                            local direction = getDirection(shotOrigin, currentTargetPart.Position)
                            local wallbangParams = RaycastParams.new(); wallbangParams.FilterType = Enum.RaycastFilterType.Include; wallbangParams.FilterDescendantsInstances = {currentTargetPart.Parent}
                            local newArgs = {self, shotOrigin, direction, wallbangParams}
                            local result = oldNamecall(unpack(newArgs))
                            return result
                        end
                        Arguments[3] = getDirection(Arguments[2], currentTargetPart.Position)
                        local result = oldNamecall(unpack(Arguments))
                        return result
                    end
                elseif (Method == "ScreenPointToRay" or Method == "ViewportPointToRay") and currentMethod == Method and self == camera then
                    shotOrigin = camera.CFrame.Position
                    local direction = (currentTargetPart.Position - shotOrigin).Unit
                    table.insert(recentShots, {origin = shotOrigin, time = tick()})
                    return Ray.new(shotOrigin, direction)
                end
            end
            return oldNamecall(...)
        end))

        local oldIndex
        oldIndex = hookmetamethod(game, "__index", newcclosure(function(self, Index)
            if checkcaller() then return oldIndex(self, Index) end
            if self == Mouse and SilentAimSettings.Enabled and SilentAimSettings.SilentAimMethod == "Mouse.Hit/Target" then
                if currentTargetPart then
                    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head") then table.insert(recentShots, {origin = LocalPlayer.Character.Head.Position, time = tick()}) end
                    if Index == "Target" or Index == "target" then return currentTargetPart
                    elseif Index == "Hit" or Index == "hit" then
                        if SilentAimSettings.BulletTP then return currentTargetPart.CFrame end
                        return (SilentAimSettings.MouseHitPrediction and (currentTargetPart.CFrame + (currentTargetPart.Velocity * currentTargetPart.Velocity.magnitude * SilentAimSettings.MouseHitPredictionAmount))) or currentTargetPart.CFrame
                    elseif Index == "X" or Index == "x" then return self.X
                    elseif Index == "Y" or Index == "y" then return self.Y
                    elseif Index == "UnitRay" then return Ray.new(self.Origin, (self.Hit.p - self.Origin.p).Unit)
                    end
                end
            end
            return oldIndex(self, Index)
        end))

        local oldRayNew
        oldRayNew = hookfunction(Ray.new, newcclosure(function(origin, direction)
            if checkcaller() then return oldRayNew(origin, direction) end
            if SilentAimSettings.Enabled and SilentAimSettings.SilentAimMethod == "Ray" and currentTargetPart and CalculateChance(SilentAimSettings.HitChance) then
                local newOrigin = origin
                if SilentAimSettings.BulletTP then newOrigin = currentTargetPart.Position + (getDirection(origin, currentTargetPart.Position).Unit * -2) end
                table.insert(recentShots, {origin = newOrigin, time = tick()})
                local newDirectionVector = getDirection(newOrigin, currentTargetPart.Position)
                return oldRayNew(newOrigin, newDirectionVector)
            end
            return oldRayNew(origin, direction)
        end))
    end
end
